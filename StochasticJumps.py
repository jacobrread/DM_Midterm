import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import math


class European_Call_Payoff:
    def __init__(self, strike):
        self.strike = strike

    def get_payoff(self, stock_price):
        if stock_price > self.strike:
            return stock_price - self.strike
        else:
            return 0


class BetaMotion:
    def simulate_paths(self):
        while(self.T - self.dt > 0):
            dWt = np.random.beta(14, 6) - .65  # Beta motion with shift to left of .65
            dYt = self.drift*self.dt + self.volatility*dWt  # Change in price
            self.current_price += dYt  # Add the change to the current price
            self.prices.append(self.current_price)  # Append new price to series
            self.T -= self.dt  # Accound for the step in time

    def __init__(self, initial_price, drift, volatility, dt, T):
        self.current_price = initial_price
        self.initial_price = initial_price
        self.drift = drift
        self.volatility = volatility
        self.dt = dt
        self.T = T
        self.prices = []
        self.simulate_paths()

class NormMotion:
    def simulate_paths(self):
        while(self.T - self.dt > 0):
            dWt = np.random.normal(self.mean, self.stdev)# F motion based on stock1.csv distribution
            dYt = self.drift*self.dt + self.volatility*dWt  # Change in price
            self.current_price += dYt  # Add the change to the current price
            self.prices.append(self.current_price)  # Append new price to series
            self.T -= self.dt  # Accound for the step in time

    def __init__(self, initial_price, drift, volatility, dt, T, mean, stdev):
        self.current_price = initial_price
        self.initial_price = initial_price
        self.drift = drift
        self.volatility = volatility
        self.dt = dt
        self.T = T
        self.mean = mean
        self.stdev = stdev
        self.prices = []
        self.simulate_paths()

# Model Parameters
paths = 5000
initial_price = 100
drift = -.01
drift2 = -0.2
drift3 = -0.2
volatility = .5
dt = 1/365
T = 1
price_paths = []
price_paths_1 = []
price_paths_2 = []

# Generate a set of sample paths
for i in range(0, paths):
    # The original motion from Part 1
    price_paths.append(BetaMotion(initial_price, drift, volatility, dt, T).prices)
    # These two distributions came from distributionFinder.ipynb and are based on the distributions found in stock1.csv and stock2-1.csv respectively
    price_paths_1.append(NormMotion(initial_price, drift2, volatility, dt, T, 0, 7.086237790774259).prices)
    price_paths_2.append(NormMotion(initial_price, drift3, volatility, dt, T, 0, 8.315813949568353).prices)

call_payoffs_average = []
call_payoffs_max = []
final_prices = []
ec = European_Call_Payoff(100)
risk_free_rate = .01

for i in range(paths):
    average = (price_paths_1[i][-1] + price_paths_2[i][-1]) / 2
    maximum = max(price_paths_1[i][-1], price_paths_2[i][-1])
    
    # Calculate the payoff based on the average of the two other prices
    # Payoff is 0 if the value would be negative
    average_payoff = (price_paths[i][-1] - average)#/(1 + risk_free_rate)
    average_payoff = 0 if average_payoff < 0 else average_payoff

    # Calculate the payoff based on the max of the two other prices
    max_payoff = (price_paths[i][-1] - maximum)#/(1 + risk_free_rate)
    max_payoff = 0 if max_payoff < 0 else max_payoff

    call_payoffs_average.append(average_payoff)  # We get the last stock price in the series generated by beta motion to determine the payoff and discount it by one year
    call_payoffs_max.append(max_payoff)  # We get the last stock price in the series generated by beta motion to determine the payoff and discount it by one year
    final_prices.append(price_paths[-1])

# Plot the set of generated sample paths for stocks1
for price_path in price_paths_1:
    plt.plot(price_path)
plt.xlabel('Days')
plt.ylabel('Price')
plt.title("Simulations of Stock Price Based on Stock1 Distribution")
plt.show()

# Plot the set of generated sample paths for stocks2
for price_path in price_paths_2:
    plt.plot(price_path)
plt.xlabel('Days')
plt.ylabel('Price')
plt.title("Simulations of Stock Price Based on Stock2 Distribution")
plt.show()

print(f"Average stock price after {int(1 / dt) * T} days: $", np.average(final_prices))

print("\nPayoff with best of average basket option with 100 stocks: $", np.average(call_payoffs_average)*100)  # Options are in blocks of 100
print("Basket option price per stock: $", np.average(call_payoffs_average))

print("\nPayoff with best of max basket option with 100 stocks: $", np.average(call_payoffs_max)*100)  # Options are in blocks of 100
print("Basket option price per stock: $", np.average(call_payoffs_max))